#!/usr/bin/env python3
"""Map injectived CLI commands by walking --help output."""

import argparse
import json
import os
import re
import shutil
import subprocess
import sys


SECTION_HEADERS = (
    "Available Commands:",
    "Commands:",
    "Additional Commands:",
    "Additional help topics:",
)
STOP_HEADERS = (
    "Flags:",
    "Global Flags:",
    "Inherited Flags:",
    "Aliases:",
    "Examples:",
    "Usage:",
)
SKIP_RECURSE = {"help", "completion"}


def resolve_binary(binary):
    if os.path.sep in binary or binary.startswith("."):
        if not os.path.exists(binary):
            raise FileNotFoundError(f"binary not found: {binary}")
        return binary

    found = shutil.which(binary)
    if not found:
        raise FileNotFoundError(f"binary not found in PATH: {binary}")
    return found


def run_help(binary, cmd_path):
    cmd = [binary] + cmd_path + ["--help"]
    result = subprocess.run(cmd, capture_output=True, text=True)
    output = result.stdout.strip() or result.stderr.strip()
    if not output:
        output = (result.stdout + "\n" + result.stderr).strip()
    return result.returncode, output


def parse_commands(help_text):
    commands = []
    in_commands = False

    for line in help_text.splitlines():
        stripped = line.strip()

        if stripped in SECTION_HEADERS:
            in_commands = True
            continue

        if in_commands and stripped in STOP_HEADERS:
            in_commands = False
            continue

        if not in_commands:
            continue

        if not stripped:
            continue

        if line.startswith("  "):
            parts = stripped.split(None, 1)
            name = parts[0]
            desc = parts[1].strip() if len(parts) > 1 else ""
            commands.append((name, desc))
            continue

        if stripped.endswith(":"):
            in_commands = False

    return commands


def should_recurse(name, cmd_path, max_depth):
    if max_depth > 0 and len(cmd_path) >= max_depth:
        return False
    if name in SKIP_RECURSE:
        return False
    if "[" in name or "]" in name:
        return False
    return True


def build_tree(binary, cmd_path, max_depth, visited):
    path_key = tuple(cmd_path)
    display_binary = os.path.basename(binary)

    node = {
        "name": display_binary if not cmd_path else cmd_path[-1],
        "description": "",
        "path": " ".join([display_binary] + cmd_path).strip(),
        "children": [],
    }

    if path_key in visited:
        node["error"] = "skipped (already visited)"
        return node

    visited.add(path_key)

    exit_code, output = run_help(binary, cmd_path)
    if exit_code != 0:
        node["error"] = f"help exit {exit_code}"

    if not output:
        if "error" not in node:
            node["error"] = "help produced no output"
        return node

    for name, desc in parse_commands(output):
        child = {
            "name": name,
            "description": desc,
            "path": " ".join([display_binary] + cmd_path + [name]).strip(),
            "children": [],
        }

        if should_recurse(name, cmd_path, max_depth):
            child = build_tree(binary, cmd_path + [name], max_depth, visited)
            child["name"] = name
            child["path"] = " ".join([display_binary] + cmd_path + [name]).strip()
            if desc and not child.get("description"):
                child["description"] = desc

        node["children"].append(child)

    return node


def render_markdown(tree):
    lines = []
    lines.append(f"# {tree['name']} CLI Map")
    lines.append("")
    lines.append("Generated by `map_injectived_cli.py` using `--help` output.")
    lines.append("")

    def walk(node, depth):
        indent = "  " * depth
        line = f"{indent}- `{node['name']}`"
        if node.get("description"):
            line += f": {node['description']}"
        if node.get("error"):
            line += f" (help error: {node['error']})"
        lines.append(line)

        for child in node.get("children", []):
            walk(child, depth + 1)

    for child in tree.get("children", []):
        walk(child, 0)

    return "\n".join(lines) + "\n"


def parse_args(argv):
    parser = argparse.ArgumentParser(
        description="Map injectived CLI commands by walking --help output.",
    )
    parser.add_argument(
        "--binary",
        default="injectived",
        help="Path to injectived binary (default: injectived)",
    )
    parser.add_argument(
        "--format",
        choices=("md", "json"),
        default="md",
        help="Output format (md or json)",
    )
    parser.add_argument(
        "--output",
        default="",
        help="Output file path (default: stdout)",
    )
    parser.add_argument(
        "--max-depth",
        type=int,
        default=0,
        help="Max command depth to recurse (0 = no limit)",
    )
    return parser.parse_args(argv)


def main(argv):
    args = parse_args(argv)

    try:
        binary = resolve_binary(args.binary)
    except FileNotFoundError as exc:
        print(str(exc), file=sys.stderr)
        return 1

    max_depth = args.max_depth
    visited = set()
    tree = build_tree(binary, [], max_depth, visited)

    if args.format == "json":
        output = json.dumps(tree, indent=2, sort_keys=True)
    else:
        output = render_markdown(tree)

    if args.output:
        with open(args.output, "w", encoding="utf-8") as handle:
            handle.write(output)
    else:
        sys.stdout.write(output)

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
